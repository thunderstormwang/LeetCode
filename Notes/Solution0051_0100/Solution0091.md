# Solution0091 Decode Ways

這題好難，想錯方法會發現有一堆 edge case 要處理

## Dynamic Programming

### 找出 dp 和下標的的意義

令 dp[n] 為長度為 n 的字串 s的解碼方法數量，換算成陣列，找 dp[n-1]

### 找出 dp 的狀態推導

這題遇到連續兩個 '0' 以上，就無法解碼，例如 "1001" 要回傳 0。  
所以跟一般的 dp 不太一樣，如果用 dp[i] = dp[i-1] + XX 之類的推導的話，會得到錯誤的結果。

這題的推導要分成兩種情況，  
先看 s[i] 是否為 '1' ~ '9'，是的話代表可單獨解碼，  
那麼 dp[i] += dp[i-1]

再看 s[i-1] 與 s[i] 的子字串是否為合法的編碼，是的話代表可跟前一個字元結合，  
那麼 dp[i] += dp[i-2]

### 找出 dp 初始值

s[0] 若為 '0' 則 dp[0] 為 0，其它情況則 dp[0] 為 1。  
s[1] 若可被單獨解碼，則 dp[1] 為 2，其它情況則 dp[1] 為 0。  

因為字串 s 的長度可能只有 1，為了計算方便，
令 dp 的長度為 n+1，
dp[0] 為 1，  
s[0] 若為 '0' 則 dp[1] 為 0，其它情況則 dp[1] 為 1。  

### 複雜度

#### Time: O(n)
- 遍歷 s: O(n)

#### Space: O(n)
- dp 的長度為 n: O(n)