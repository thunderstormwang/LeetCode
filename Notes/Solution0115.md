# Solution0115

與 [Solution0392](Solution0392.md) 不同，無法再用雙指針了

## 動態規劃 - 2維陣列

雖然是 hard，還是靠自己想出來了  
因為最近做了很多類似的圖目，畫了矩陣後，誤打誤撞解出來了~ XD

### 找出 dp 和下標的的意義

在長度為 n 的 s 與長度為 m 的 t，s 能找到的不同子字串且等於 t 的數目為 dp(n,m)，換算成陣列求 dp[n-1][m-1]

### 找出 dp 的狀態推導

dp[i][j] 的來源有以下
- s[i] = t[j]，為以下兩者相加
  - 長度為 i-1 的 s 與長度為 j-1 的 t 的結果，也就是 dp[i-1][j-1]
  - 長度為 i-1 的 s 與長度為 j 的 t 的結果，也就是 dp[i-1][j]
- 反之，就是沿用長度為 i-1 的 s 與長度為 j 的 t 的結果，也就是 dp[i-1][j]

為什麼能推出上述結果，還是挺神奇的...，只能說畫出矩陣和推導後，就是這樣

### 找出 dp 初始值

因為計算來源有 dp[i-1][j-1]，須把 dp[0][j] 另外計算，發現要想一些判斷，dp[i][0] 也是一樣的情況

讓陣列的數目各加 1，可免去這些麻煩，換成求 dp[n][m]

dp[i][0] = 1，0 <= i <= n，t 為空字串，s 唯有空字串能符合  
dp[0][j] = 0，1 <= j <= m，s 為空字串，無法組成 t

### 複雜度

#### Time: O(n*m)

#### Space: O(n*m)

---

## 動態規劃 - 1維陣列

dp[i][j] 的來源有以下
- dp[i-1][j-1] + 1
- Max(dp[i-1][j], dp[i][j-1])

若簡化成一維陣列，dp[i-1][j-1]、dp[i][j-1] 都會變成 dp[j-1]，差別是 dp[i-1][j-1] 是舊值，經過計算會被蓋掉變成 dp[i][j-1] 成為新值

需要把 dp[i-1][j-1] 先存起來再作計算

```csharp
temp = dp[j]
if (text1[i] == text2[j])
{
    dp[j] = pre + 1
}
else
{
    dp[j] = Math.Max(dp[j-1], dp[j])
}
pre = temp;
j++;
```

### 複雜度

#### Time: O(n*m)

#### Space: O(m)
