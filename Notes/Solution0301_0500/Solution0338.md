# Solution0338 Counting Bits

我只想得出暴力法，O(n) 的方法完全想不到

## Ver1 - 暴力法

在 1~n 每個數字都要計算其 bit 數量，然後放入答案中

### 複雜度

#### Time: O(n * log(n))
- 計算 bit 數要 log(n)，且總共 n 個數要計算: O(n * log(n))

#### Space: O(1)

---

## Ver2 - Dynamic Programming + Bit Manipulation

### 找出 dp 的狀態推導

令 dp(n) 為數字 n 的 bit 為 1 的數量

### 找出 dp 的狀態推導

dp[i] = dp[i / 2] + i % 2

### 找出 dp 初始值

dp[0] = 0

### 複雜度

#### Time: O(n)

#### Space: O(1)

---

## Ver3 - Dynamic Programming + Bit Manipulation

### 找出 dp 的狀態推導

以 0 到 15 為例

i  | 二進位表示法 | Bit 為 1 的數量 | i & (i - 1) | i & (i - 1) 的 Bit 為 1 的數量
---|--------------|-----------------|-------------|--------------------------
1  | 0001         | 1               | 0000        | 0
2  | 0010         | 1               | 0000        | 0
3  | 0011         | 2               | 0010        | 1
4  | 0100         | 1               | 0000        | 0
5  | 0101         | 2               | 0100        | 1
6  | 0110         | 2               | 0100        | 1
7  | 0111         | 3               | 0110        | 2
8  | 1000         | 1               | 0000        | 0
9  | 1001         | 2               | 1000        | 1
10 | 1010         | 2               | 1000        | 1
11 | 1011         | 3               | 1010        | 2
12 | 1100         | 2               | 1000        | 1
13 | 1101         | 3               | 1100        | 2
14 | 1110         | 3               | 1100        | 2
15 | 1111         | 4               | 1110        | 3


i & (i - 1) 是個快速的方法判斷是否為 2 的次方數，如果是的話，i & (i - 1) 會是 0。

i & (i - 1) 會把 i 最右邊的 1 變成 0，所以 i & (i - 1) 的 bit 為 1 的數量就是 i 的 bit 為 1 的數量 - 1

那就可以做出狀態轉移方程式了  
dp[i] = dp[i & (i - 1)] + 1