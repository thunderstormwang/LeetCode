# Solution0123

## 暴力法

我沒想到怎麼用動態規劃解這題，我想到將 prices 切成兩段，每段各算出最大的獲利再相加，然後逐一算出每一段的最大獲利再找最大值，這應該算暴力法

### 複雜度

#### Time: O(n<sup>2</sup>)

#### Memory: O(n)

---

## 動態規劃

跟 [Solution122](Solution0122.md) 類似，也是算累計獲利，但被限制最多買賣兩次

### 找出 dp 和下標的的意義

dp(n, 0): 第 n 天且第一次持有股票的累計獲利，換算成陣列，求 `dp[n-1][0]`  
dp(n, 1): 第 n 天且第一次無持有股票的累計獲利，換算成陣列，求 `dp[n-1][1]`  
dp(n, 2): 第 n 天且第二次持有股票的累計獲利，換算成陣列，求 `dp[n-1][2]`  
dp(n, 3): 第 n 天且第二次無持有股票的累計獲利，換算成陣列，求 `dp[n-1][3]`  

因為題目要求最多買賣兩次且最後不能持有股票，所以 `dp[n-1][3]` 就是答案  

### 找出 dp 的狀態推導

第 i 天且第一次持有股票的累計獲利的來源有以下
- 第 i-1 天且第一次持有股票的累計獲利  
- 第 i 天買入股票的累計獲利  

兩者取最大，所以 `dp[i][0] ＝ Math.Max(dp[i-1][0], -prices[i])`  

第 i 天且第一次無持有股票的累計獲利的來源有以下  
- 第 i-1 天且第一次無持有股票的累計獲利  
- 第 i-1 天且第一次持有股票的累計獲利 加上 第 i 天賣股票的獲利  

兩者取最大，所以 `dp[i][1] ＝ Math.Max(dp[i-1][1], dp[i-1][0] + prices[i])`  

第 i 天且第二次持有股票的累計獲利的來源有以下  
- 第 i-1 天且第二次持有股票的累計獲利
- 第 i-1 天且第一次無持有股票的累計獲利 扣掉 第 i 天買入股票的成本  

兩者取最大，所以 `dp[i][2] ＝ Math.Max(dp[i-1][2], dp[i-1][1] - prices[i])`  

第 i 天且第二次無持有股票的累計獲利的來源有以下  
- 第 i-1 天且第二次無持有股票的累計獲利  
- 第 i-1 天且第二次持有股票的累計獲利 加上 第 i 天賣股票的獲利  

兩者取最大，所以 `dp[i][3] ＝ Math.Max(dp[i-1][3], dp[i-1][2] + prices[i])`  

### 找出 dp 初始值

第一天且第一次持有股票，前面不會再有前一天了，只有買入股票此一情況，`dp[0][0] = -prices[0]`  
第一天且第一次無持有股票，沒股票可賣，`dp[0][1] = 0`  
第一天且第二次持有股票，這裡最難想，可以想作是第一次買賣股票後是不賺不賠，`dp[0][2] = dp[0][1] -prices[0]`  
第一天且第二次無持有股票，沒股票可賣，`dp[0][3] = 0`    

### 複雜度

#### Time: O(n)

#### Memory: O(n)