# Solution0031 Next Permutation

因為要求只能用固定空間 O(1)，所以用暴力法找出所有組合並排序後，再找出下一個排列的方法不可行

做第二次，不過還是忘掉了...

這題也沒用到遞迴，grind 應該分錯了

## Ver1 - Two Pointer

這題不錯，難在找規則，用長度 4 的陣列應該較好推出規則來了

以 87536421 為例

從左往右尋找最後一個上升的 i，nums[i] > num[i-1]  
從 i(包括 i) 之後都是下降，它們的下個排列肯定要由低到到高  
例如 87536421，最後一個上升點是 36，而 6421 已是由高到低  

尋找最大的 j，i <= j < nums.Length 且 nums[i] < nums[j]  
將 nums[i], nums[j] 作交換，則讓 i(包括 i) 之後仍維持下降  
例如 3 跟 4 交換後，讓 6421 變成 6321 後再作排序，讓整個字串變成 87541236，這樣就能得到下一個排列了  

將 i(包括 i) 之後的元素改從小排到大，因為原本已是大到小，用雙指針交換即可  

### 複雜度

#### Time: O(n)

#### Space: O(1)

---

## Ver2 - Two Pointer

同樣做法，只是從右邊開始找起

### 複雜度

#### Time: O(n)

#### Space: O(1)