# Solution1049

## 動態規劃 - Ver1 - 01背包 - 2維陣列

01背包問題，從 n 個物品中任意挑選，每個物品只能選或不選一次，放入容量 w 的背包，求能放入背包的最大價值 v

初次看到也想不到怎麼轉換成 01 背包，看了解答才知道是將石頭分成重量相近的兩堆，兩堆的重量相減的的絕對值就是答案了

所以可以將題目看作，從 n 個石頭任意挑選，每個石頭只能選或不選一次，放入容量 sum/2 的容器，求能放入該容器的最大結果 v 

=> 計算 Abs(v - (sum-v)) => 計算 Abs(2v - sum)

### 找出 dp 和下標的的意義
從 石頭<sub>0</sub>, ..., 石頭<sub>n-1</sub> 共 n 個石頭任意挑選，每個石頭只能選或不選，求放入容量 sum/2 的最大結果 = dp(n, sum/2)

換算成陣列，dp[i][j] 的定義是從 i-1 個石頭任意挑選，每個數字只能選或被選一次，能放入容量 j 的最大結果。0 <= i < n, 0 <= j <= sum/2

也就是我們要算出 dp[n-1][sum/2]

### 找出 dp 的狀態推導
dp[i][j] 有兩種可能
- 不選 石頭<sub>i</sub> 或者說無法放入 石頭<sub>i</sub>，dp[i][j] = dp[i-1][j]
- 選 石頭<sub>i</sub> ，意即從 i-1 個數挑選，求能放入容量 j - 石頭<sub>i</sub> 的容器的最大結果 加上 石頭<sub>i</sub>，dp[i][j] = dp[i-1][j - 石頭<sub>i</sub>] + 石頭<sub>i</sub>

從以上兩者取最大

### 找出 dp 初始值
- dp[i][0] = 0，0 <= i < n，容量是 0 怎麼放結果都是 0
- dp[0][j] = 0，石頭<sub>0</sub> <= j <= sum/2，容量至少要大於等於 石頭<sub>0</sub> 才能將它放入

### 複雜度

#### Time: O(n<sup>2</sup>)

n 個數，每個數至少為 1，所以巢狀迴圈要跑 n * n 次

#### Space: O(n<sup>2</sup>)

---

## 動態規劃 - Ver2 - 01背包 - 1維陣列

從二維陣列改一維陣列需要顧慮的點有，前一個要被計算的數值不能被蓋掉

在狀態推導中，dp[i][j] 有二：
- dp[i-1][j]，也就是從上方傳下來，也可以說就是本身的前一個數值
- dp[i-1][j - 石頭<sub>i</sub>] + 石頭<sub>i</sub>，不確定 j - 石頭<sub>i</sub> 是多少，但肯定比 j 小

所以如果將 j 從由大到小走迴圈，就不用擔心前一個數值被蓋掉了

那麼就可以選用一維陣列，dp[j] = Max(d[j], dp[j - 石頭<sub>i</sub>] + 石頭<sub>i</sub>)

### 複雜度

#### Time: O(n<sup>2</sup>)

#### Space: O(n)
