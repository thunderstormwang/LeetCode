# Solution0091 Decode Ways

這題好難，想錯方法會發現有一堆 edge case 要處理

## Ver1 - Dynamic Programming

### 找出 dp 和下標的的意義

令 dp[n] 為長度為 n 的字串 s的解碼方法數量，換算成陣列，找 dp[n-1]

### 找出 dp 的狀態推導

這題遇到連續兩個 '0' 以上，就無法解碼，例如 "1001" 要回傳 0。  
所以跟一般的 dp 不太一樣，通常 dp[i] 會 >= dp[i-1]，以此例來說，有可能將 0 擴散到最後。

如果子字串 s[i-1] ~ s[i] 是 "11"~"19" 或 "21"~"26"，則 s[i] 可被單獨解碼又可和 [i-1] 合併解碼。  
dp[i] = dp[i-1] + dp[i-2]  

如果子字串 s[i-1] ~ s[i] 是 "10" 或 "20"，則 s[i] 必須和 [i-1] 合併解碼。  
dp[i] = dp[i-2]  

如果子字串 s[i] 是 "1" ~ "9"，且 s[i-1] ~ s[i] 又不屬於第一種情況，則 s[i] 可被單獨解碼。  
dp[i] = dp[i-1]  

### 找出 dp 初始值

s[0] 若為 '0' 則 dp[0] 為 0，其它情況則 dp[0] 為 1。  
s[1] 若可被單獨解碼，則 dp[1] 為 2，其它情況則 dp[1] 為 0。  

因為字串 s 的長度可能只有 1，為了計算方便，
令 dp 的長度為 n+1，
dp[0] 為 1，  
s[0] 若為 '0' 則 dp[1] 為 0，其它情況則 dp[1] 為 1。  

### 複雜度

#### Time: O(n)
- 遍歷 s: O(n)

#### Space: O(n)
- dp 的長度為 n: O(n)

---

## Ver2 - Dynamic Programming

Ver1 的解法應該會碰到多次 edge case 才寫得出來。
這是網路上較多人用的解法，將狀態推導簡化。  

### 找出 dp 的狀態推導

將推導改用累加，並分成兩種情況，  
先看 s[i] 是否為 '1' ~ '9'，是的話代表可單獨解碼，  
那麼 dp[i] += dp[i-1]  

再看 s[i-1] 與 s[i] 的子字串是否為合法的編碼，是的話代表可跟前一個字元結合，  
那麼 dp[i] += dp[i-2]  