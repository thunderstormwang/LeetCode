# Solution0188

## 動態規劃

跟 [Solution123](../Solution0101_0150/Solution0123.md) 類似，也是算累計獲利，但被限制最多買賣 k 次

那就改成陣列：

dp(n, 0): 第 n 天且第一次持有股票的累計獲利，換算成陣列，求 `dp[n-1][0]`  
dp(n, 1): 第 n 天且第一次無持有股票的累計獲利，換算成陣列，求 `dp[n-1][1]`  
...  
dp(n, 2 * (k-1)): 第 n 天且第二次持有股票的累計獲利，換算成陣列，求 `dp[n-1][2* k -2]`  
dp(n, 2 * (k-1) + 1): 第 n 天且第二次無持有股票的累計獲利，換算成陣列，求 `dp[n-1][2 * k - 1]`

因為題目要求最多買賣 k 次且最後不能持有股票，所以 `dp[n-1][2 * k - 1]` 就是答案

推導上，只有第一次持有股票的算法跟非第一次持有股票的算法不同，其他都一樣

`dp[i][j]` 且 `j == 0` (第一次持有股票)的來源有以下
- 第 i-1 天且第一次持有股票的累計獲利，`dp[i-1][j]`
- 第 i 天買入股票的累計獲利，`-1 * prices[i]`

兩者取最大

`dp[i][j]` 且 `j % 2 == 0` (非第一次持有股票)的來源有以下
- 第 i-1 天就持有股票的累計獲利，`dp[i-1][j]`
- 第 i-1 天無持有股票的累計獲利 扣掉 第 i 天買入股票的成本，`dp[i-1][j-1] - prices[i]`

兩者取最大

`dp[i][j]` 且 `j % 2 == 1`(無持有股票)的來源有以下
- 第 i-1 天就無持有投票的累計獲利，`dp[i-1][j]`
- 第 i-1 天且持有股票的累計獲利 加上 第 i 天賣股票的獲利，`dp[i-1][j-1] + prices[i]`

兩者取最大

### 複雜度

#### Time: O(n)

#### Memory: O(k*n)