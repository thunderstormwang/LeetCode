# Solution0188

## 動態規劃

跟 [Solution123](../Solution0101_0150/Solution0123.md) 類似，也是算累計獲利，但被限制最多買賣 k 次

### 找出 dp 的狀態推導

那就改成陣列：

dp(n, 1, 0): 第 n 天且第一次持有股票的累計獲利  
dp(n, 1, 1): 第 n 天且第一次無持有股票的累計獲利  
...  
dp(n, k, 0): 第 n 天且第 k 次持有股票的累計獲利  
dp(n, k, 1): 第 n 天且第 k 次無持有股票的累計獲利  

因為題目要求最多買賣 k 次且最後不能持有股票，所以 `dp[n-1][2 * k - 1]` 就是答案

推導上，只有第一次持有股票的算法跟非第一次持有股票的算法不同，其他都一樣

第 i 天且第 1 次持有股票的累積獲利來源有以下  
- 第 i-1 天且第 1 次持有股票的累計獲利  
- 第 i 天買入第 1 次股票的成本    

兩者取最大，dp(i, 1, 0) = Max(dp(i-1, 1, 0), -price[i])  

第 i 天且非第 1 次持有股票的累積獲利來源有以下  
- 第 i-1 天且第 j 次持有股票的累計獲利  
- 第 i-1 天且第 j-1 次無持有股票的累計獲利 扣掉 第 i 天買入股票的成本  

兩者取最大，當 j > 1，dp(i, j, 0) = Max(dp(i-1, j, 0), dp(i-1, j-1, 0) - price[i])  

第 i 天且第 j 次無持有股票的累積獲利來源有以下  
- 第 i-1 天就第 j 次無持有投票的累計獲利  
- 第 i-1 天且第 j-1 次持有股票的累計獲利 加上 第 i 天賣股票的獲利  

兩者取最大，dp(i, j, 1) = Max(dp(i-1, j, 1), dp(i-1, j-1, 1) + price[i])  

### 找出 dp 初始值

第一天且第一次持有股票，前面不會再有前一天了，只有買入股票此一情況，dp(1, 1, 0) ＝ -prices[0]  
第一天且第 j 次持有股票，這裡最難想，可以想作是前幾次買賣股票後是不賺不賠，dp(1, j, 0) ＝ -prices[0]  
第一天且第 j 次無持有股票，第一天沒股票可賣，dp(1, j, 0) = 0  

### 轉換成陣列  

dp(n, 1, 0): `dp[n-1][0]`  
dp(n, 1, 1): `dp[n-1][1]`  
...  
p(n, i, 0): `dp[n-1][2 * i - 2]`  
dp(n, i, 1): `dp[n-1][2 * i - 1]`  
...  
dp(n, k, 0): `dp[n-1][2 * k - 2]`  
dp(n, k, 1): `dp[n-1][2 * k - 1]`  

### 複雜度

#### Time: O(n)

#### Memory: O(k*n)