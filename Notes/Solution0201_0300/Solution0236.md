# Solution0236 Lowest Common Ancestor of a Binary Tree

跟 [Solution0235](Solution0235.md) 很像

Ver1 是自己想的做法，寫起來有點卡卡的，覺得有重覆的計算，但也想不到怎麼優化，寫完後再去看解答寫出 Ver2

## Ver1

用 postorder 的順序遍歷所有節點

遞迴找左子樹的結果，如果有回傳正向結果不用再往下做，直接回傳左子樹的結果  
如果左子樹也沒有正向結果，遞迴找右子樹的結果，如果有回傳正向結果不用再往下做，直接回傳右子樹的結果  
如果右子樹也沒有正向結果  
- foundP = 檢查左子樹有找到 p 或 右子樹是否有找到 p 或本身是否為 p
- foundQ = 檢查左子樹有找到 q 或 右子樹是否有找到 q 或本身是否為 q  

如果 foundP 和 foundQ 皆為 true，回傳 root，反之回傳 null，讓上層判斷  

### 複雜度

#### Time: O(n)
- 最差情況下會遞迴 n 層: O(n)

#### Space: O(n)
- 最多會遞迴 n 層: O(n)

---

## Ver2

看了解答才知有更簡潔的做法，這做法真精巧，每個節點回傳的結果不一定對，直到回到某個節點就開始正確

如果 root 就為 p 或 q 其中之一，則 root 就是可能的最小共同祖先的候選者之一，因為就算再往下找且也真的找到另外一個節點，也不會改變 root 就是最小共同祖先，所以直接回傳 root

遞迴回到上層後，如果某個節點找到左子樹 和 右子樹 都不為 null，就代表此節點即為最小共同祖先，那就改回傳當前節點，也就把回傳結果修正了，反之，就回傳 左子樹 或 右子樹 不為 null 的那一邊；皆為 null 就回傳 null

### 複雜度

#### Time: O(n)
- 最差情況下會遞迴 n 層: O(n)

#### Space: O(n)
- 最多會遞迴 n 層: O(n)